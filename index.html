<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Dear Laily — Cinematic Space</title>

<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;700&family=Great+Vibes&display=swap" rel="stylesheet">

<style>
html,body{
  margin:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#000;
  font-family:'Playfair Display',serif;
}
#start{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  color:#fff;
  font-size:22px;
  letter-spacing:1px;
  z-index:10;
  cursor:pointer;
}
#indicator{
  position:fixed;
  bottom:18px;
  left:50%;
  transform:translateX(-50%);
  color:#fff;
  font-size:14px;
  opacity:0;
  transition:opacity .4s;
  z-index:5;
}
#status{
  position:fixed;
  top:14px;
  left:14px;
  padding:6px 10px;
  font-size:12px;
  color:#fff;
  background:rgba(0,0,0,.45);
  backdrop-filter:blur(6px);
  border-radius:6px;
  z-index:5;
}
#camBox{
  position:fixed;
  right:10px;
  bottom:10px;
  width:140px;
  height:190px;
  border:1px solid rgba(255,255,255,.4);
  border-radius:10px;
  overflow:hidden;
  display:none;
  z-index:4;
}
#camBox video{
  width:100%;
  height:100%;
  object-fit:cover;
  transform:scaleX(-1);
}
#camBox span{
  position:absolute;
  bottom:6px;
  left:0;
  right:0;
  text-align:center;
  font-size:10px;
  color:#fff;
  opacity:.7;
}
canvas{display:block}
</style>
</head>
<body>

<div id="start">Tap anywhere to start</div>
<div id="indicator"></div>
<div id="status">CAMERA: OFF</div>

<div id="camBox">
  <video id="cam" autoplay muted playsinline></video>
  <span>Place your hand in the center</span>
</div>

<audio id="music" loop preload="auto">
  <source src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_8b1e76a7b3.mp3?filename=space-ambient-110997.mp3" type="audio/mpeg">
</audio>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<script>
/* ================= DOM ================= */
const start=document.getElementById('start')
const indicator=document.getElementById('indicator')
const statusEl=document.getElementById('status')
const camBox=document.getElementById('camBox')
const video=document.getElementById('cam')
const music=document.getElementById('music')

/* ================= THREE SCENE ================= */
const scene=new THREE.Scene()
scene.fog=new THREE.FogExp2(0x060018,0.0018)

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,1500)
camera.position.z=160

const renderer=new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
renderer.setPixelRatio(Math.min(devicePixelRatio,2))
document.body.appendChild(renderer.domElement)

/* ================= STAR PARTICLES ================= */
const COUNT=20000
const pos=new Float32Array(COUNT*3)
const base=new Float32Array(COUNT*3)
const target=new Float32Array(COUNT*3)
const twinkle=new Float32Array(COUNT)

for(let i=0;i<COUNT;i++){
  const r=Math.random()*400
  const theta=Math.random()*Math.PI*2
  const phi=Math.acos((Math.random()*2)-1)

  base[i*3]=r*Math.sin(phi)*Math.cos(theta)
  base[i*3+1]=r*Math.cos(phi)
  base[i*3+2]=r*Math.sin(phi)*Math.sin(theta)

  pos.set(base.slice(i*3,i*3+3),i*3)
  target.set(base.slice(i*3,i*3+3),i*3)

  twinkle[i]=Math.random()*Math.PI*2
}

const geo=new THREE.BufferGeometry()
geo.setAttribute('position',new THREE.BufferAttribute(pos,3))

const mat=new THREE.PointsMaterial({
  color:0xcfe9ff,
  size:1.6,
  transparent:true,
  opacity:0.85,
  blending:THREE.AdditiveBlending,
  depthWrite:false
})

const stars=new THREE.Points(geo,mat)
scene.add(stars)

/* ================= STATE ================= */
const STATE={IDLE:0,TRANSITION:1,DISPLAY:2}
let state=STATE.IDLE
let activeGesture=null
let morphT=0
let morphDur=2

/* ================= SHAPES ================= */
function buildText(text){
  const chars=[...text]
  for(let i=0;i<COUNT;i++){
    const c=i%chars.length
    target[i*3]=(c-chars.length/2)*2.5
    target[i*3+1]=Math.sin(i*.12)*5
    target[i*3+2]=(Math.floor(i/chars.length)%16-8)*2.5
  }
}
function buildHeart(){
  for(let i=0;i<COUNT;i++){
    const t=Math.random()*Math.PI*2
    const r=26*(1-Math.sin(t))
    target[i*3]=r*Math.cos(t)
    target[i*3+1]=r*Math.sin(t)
    target[i*3+2]=(Math.random()-.5)*10
  }
}
function toGalaxy(){
  target.set(base)
  morphT=0
  state=STATE.TRANSITION
  activeGesture=null
}

/* ================= APPLY ================= */
function applyGesture(g){
  morphT=0
  morphDur=1.5+Math.random()
  state=STATE.DISPLAY
  activeGesture=g

  if(g===1)buildText(`Dear Laily Aliyah,
I want to sincerely apologize for the situation that happened. I’m truly sorry if everything made you feel disappointed, confused, or hurt. What hurts me the most is knowing that you thought I was lying, even though I was being honest from the beginning.`)
  if(g===2)buildText(`I never intended to deceive you or break your trust in any way. I understand why you might have felt that way, and I respect your feelings. Still, I hope one day you can believe that my words were genuine and came from a sincere place.`)
  if(g===3)buildText(`I’m really sorry for the misunderstanding, and I truly hope we can clear things up and move forward with honesty and respect.`)
  if(g===4)buildHeart()
  if(g===5)buildText(`ilysm ly ♥`)
  if(g==="fist")buildText(`from: Raja Iblis`)

  indicator.textContent=`Gesture detected: ${g}`
  indicator.style.opacity=1
  setTimeout(()=>indicator.style.opacity=0,900)
}

/* ================= GESTURE FILTER ================= */
let buffer=[],stable=null,stableSince=0
const WINDOW=12,STABLE_MS=300
function pushGesture(g){
  buffer.push(g)
  if(buffer.length>WINDOW)buffer.shift()
  if(buffer.every(v=>v===buffer[0])){
    if(stable!==buffer[0]){
      stable=buffer[0]
      stableSince=performance.now()
    }
    if(performance.now()-stableSince>=STABLE_MS) return stable
  }
  return null
}

/* ================= CAMERA ================= */
let mediaStream=null,hands=null,cam=null
async function requestCamera(){
  statusEl.textContent="CAMERA: REQUESTING"
  try{
    mediaStream=await navigator.mediaDevices.getUserMedia({
      video:{facingMode:"user",width:{ideal:640},height:{ideal:480}},
      audio:false
    })
    video.srcObject=mediaStream
    await video.play()
    statusEl.textContent="CAMERA: LIVE"
    camBox.style.display='block'
    startHands()
  }catch(e){
    statusEl.textContent="CAMERA: DENIED"
    setTimeout(requestCamera,3000)
  }
}
function startHands(){
  hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`})
  hands.setOptions({maxNumHands:1,minDetectionConfidence:.6,minTrackingConfidence:.6})
  hands.onResults(onHands)
  cam=new Camera(video,{
    onFrame:async()=>{ if(video.readyState>=2) await hands.send({image:video}) },
    width:640,height:480
  })
  cam.start()
}
function onHands(res){
  if(!res.multiHandLandmarks){
    if(state===STATE.DISPLAY)toGalaxy()
    return
  }
  const lm=res.multiHandLandmarks[0]
  const tips=[4,8,12,16,20]
  let fingers=0
  for(let i=1;i<tips.length;i++){
    if(lm[tips[i]].y<lm[tips[i]-2].y)fingers++
  }
  if(fingers===0)fingers="fist"
  const valid=pushGesture(fingers)
  if(valid!==null && valid!==activeGesture)applyGesture(valid)
}

/* ================= START ================= */
start.onclick=async()=>{
  start.style.display='none'
  try{await music.play();music.volume=.35}catch(e){}
  requestCamera()
}

/* ================= ANIMATE ================= */
let mx=0,my=0
window.onmousemove=e=>{
  mx=(e.clientX/innerWidth-.5)*2
  my=(e.clientY/innerHeight-.5)*2
}

function animate(t){
  requestAnimationFrame(animate)

  for(let i=0;i<COUNT;i++){
    twinkle[i]+=0.01
    mat.opacity=0.75+0.1*Math.sin(twinkle[i])
  }

  morphT=Math.min(morphT+1/60/morphDur,1)
  const e=morphT<.5?4*morphT*morphT*morphT:1-Math.pow(-2*morphT+2,3)/2
  for(let i=0;i<COUNT*3;i++){
    pos[i]+= (target[i]-pos[i])*e
  }
  geo.attributes.position.needsUpdate=true

  stars.rotation.y+=0.00025
  stars.rotation.x+=0.0001
  camera.position.x+=(mx*25-camera.position.x)*.04
  camera.position.y+=(-my*25-camera.position.y)*.04

  renderer.render(scene,camera)
}
animate(0)

onresize=()=>{
  camera.aspect=innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth,innerHeight)
}
</script>
</body>
</html>
