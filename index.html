<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"/>
<title>Dear Laily â€” Star Message</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: radial-gradient(ellipse at bottom, #07001a 0%, #000000 70%);
}
canvas { display: block; }

#camera-box {
  position: fixed;
  top: 14px;
  right: 14px;
  width: 140px;
  height: 190px;
  border-radius: 14px;
  overflow: hidden;
  background: #000;
  border: 1px solid rgba(180,140,255,0.35);
  z-index: 10;
}
#camera-box video {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transform: scaleX(-1);
}
#camera-guide {
  position: absolute;
  inset: 10px;
  border: 1px dashed rgba(255,255,255,0.45);
  border-radius: 10px;
}
#debug {
  position: fixed;
  left: 14px;
  bottom: 14px;
  font-family: monospace;
  font-size: 12px;
  color: #9bb0ff;
  z-index: 10;
}
</style>
</head>

<body>

<div id="camera-box">
  <video id="camera" autoplay playsinline muted></video>
  <div id="camera-guide"></div>
</div>
<div id="debug">gesture: idle</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
/* =========================
   CAMERA
========================= */
const video = document.getElementById("camera");
navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" }, audio: false })
  .then(s => video.srcObject = s);

/* =========================
   THREE SETUP
========================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050010, 0.0012);

const camera3D = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera3D.position.z = 120;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
document.body.appendChild(renderer.domElement);

/* =========================
   STAR TEXTURE
========================= */
function createStarTexture() {
  const c = document.createElement("canvas");
  c.width = c.height = 64;
  const ctx = c.getContext("2d");
  const g = ctx.createRadialGradient(32,32,0,32,32,32);
  g.addColorStop(0,"rgba(255,255,255,1)");
  g.addColorStop(0.4,"rgba(180,200,255,0.7)");
  g.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,64,64);
  return new THREE.CanvasTexture(c);
}
const starTexture = createStarTexture();

/* =========================
   STAR FIELD
========================= */
const COUNT = 1200;
const geo = new THREE.BufferGeometry();
const pos = new Float32Array(COUNT * 3);
const basePos = new Float32Array(COUNT * 3);

for (let i = 0; i < COUNT; i++) {
  const i3 = i * 3;
  basePos[i3] = pos[i3] = (Math.random() - 0.5) * 400;
  basePos[i3+1] = pos[i3+1] = (Math.random() - 0.5) * 400;
  basePos[i3+2] = pos[i3+2] = (Math.random() - 0.5) * 400;
}

geo.setAttribute("position", new THREE.BufferAttribute(pos, 3));

const mat = new THREE.PointsMaterial({
  size: 2.2,
  map: starTexture,
  transparent: true,
  opacity: 0.9,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const stars = new THREE.Points(geo, mat);
scene.add(stars);

/* =========================
   TEXT TARGET (OFFSCREEN)
========================= */
function generateTextTargets(text) {
  const c = document.createElement("canvas");
  c.width = 800;
  c.height = 200;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.font = "64px serif";
  ctx.textAlign = "center";
  ctx.fillStyle = "white";
  ctx.fillText(text, c.width/2, c.height/2);

  const data = ctx.getImageData(0,0,c.width,c.height).data;
  const targets = [];

  for (let y = 0; y < c.height; y += 4) {
    for (let x = 0; x < c.width; x += 4) {
      const i = (y * c.width + x) * 4;
      if (data[i+3] > 150) {
        targets.push({
          x: (x - c.width/2) * 0.3,
          y: (c.height/2 - y) * 0.3,
          z: 0
        });
      }
    }
  }
  return targets;
}

const textTargets = generateTextTargets("Dear Laily");

/* =========================
   STATE
========================= */
let mode = "idle"; // idle | text

/* =========================
   MEDIAPIPE + STABILIZER
========================= */
let lastGesture="none", stableGesture="none", t0=0;
const HOLD=800;
const debug=document.getElementById("debug");

const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:1,modelComplexity:0,minDetectionConfidence:0.6,minTrackingConfidence:0.6});

hands.onResults(r=>{
  if(!r.multiHandLandmarks||!r.multiHandedness){stableGesture="none";return;}
  const lm=r.multiHandLandmarks[0];
  const up=(a,b)=>lm[a].y<lm[b].y;
  const index=up(8,6), middle=up(12,10), ring=up(16,14), pinky=up(20,18);
  let g="other";
  if(index&&!middle&&!ring&&!pinky) g="1 finger";
  const now=performance.now();
  if(g!==lastGesture){lastGesture=g;t0=now;stableGesture="none";}
  else if(now-t0>HOLD) stableGesture=g;
  debug.textContent="gesture: "+(stableGesture||"detecting");
});

new Camera(video,{onFrame:async()=>hands.send({image:video}),width:640,height:480}).start();

/* =========================
   ANIMATE
========================= */
function animate() {
  requestAnimationFrame(animate);

  if (stableGesture === "1 finger") mode = "text";
  else mode = "idle";

  const p = geo.attributes.position.array;

  for (let i = 0; i < COUNT; i++) {
    const i3 = i * 3;
    let tx, ty, tz;

    if (mode === "text" && i < textTargets.length) {
      tx = textTargets[i].x;
      ty = textTargets[i].y;
      tz = textTargets[i].z;
    } else {
      tx = basePos[i3];
      ty = basePos[i3+1];
      tz = basePos[i3+2];
    }

    p[i3]     += (tx - p[i3]) * 0.08;
    p[i3 + 1] += (ty - p[i3 + 1]) * 0.08;
    p[i3 + 2] += (tz - p[i3 + 2]) * 0.08;
  }

  geo.attributes.position.needsUpdate = true;
  renderer.render(scene, camera3D);
}
animate();
</script>
</body>
</html>
